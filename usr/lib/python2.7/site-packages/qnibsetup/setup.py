#! /usr/bin/env python
# -*- coding: utf-8 -*-

# load librarys
import os
import re
import socket

import envoy
import etcd
import netifaces
import qnibsetup

__author__    = 'Christian Kniep <christian()qnib.org>'
__copyright__ = 'Copyright 2014 Christian Kniep'
__license__   = """MIT License (http://opensource.org/licenses/MIT)"""

## Service map
SERVICE_MAP = {
    53: {'src': 'dns', 'dst': []},
    4001: {'src': 'etcd', 'dst': []},
    2003: {'src': 'carbon', 'dst': ['diamond']},
    514: {'src': 'syslog', 'dst': ['syslog-ng']},
    5514: {'src': 'logstash', 'dst': ['syslog-ng']},
    }


def reverse_map(srv_name):
    """ returns port, dst
    """
    for port, val in SERVICE_MAP.items():
        if srv_name == val['src']:
            return {'port': port, 'dst': val['dst']}
    return None


class QnibSetup(object):
    """ Fetches the environment and act accordingly
    """

    def __init__(self, cfg):
        """ Init of instance
        """
        self._cfg = cfg
        if not self._cfg.has_option('defaults', 'docker_dns'):
            self.update_cfg('defaults', 'docker_dns', 'False')
        self._plugins = {}
        self._srv_check = {}

    def update_cfg(self, sec, opt, val):
        """ update the config and write file
        """
        if not self._cfg.has_option(sec, opt) or \
                self._cfg.get(sec, opt) != str(val):
            self._cfg.set(sec, opt, val)
            self._cfg.update_file()
            return True
        return False

    def run(self):
        """ main run method
        """
        self.read_local_dns_server()
        self.eval_linked_containers()
        self.eval_services()
        self.check_services()

    def check_services(self):
        """ checks services afterwards
        """
        for srv, stat in self._srv_check.items():
            if stat == 'restart':
                self.restart_supervisor(srv)
            elif stat == 'check':
                self.check_supervisor(srv)

    def eval_services(self):
        """ iterates over services and checks for changes
        """
        sec = 'services'
        for srv_name in self._cfg.options(sec):
            self.setup(srv_name)

    def check_supervisor(self, srv_name):
        """ checks if srv is RUNNING
        """
        cmd = "supervisorctl status %s" % srv_name
        proc = envoy.run(cmd)
        std_out = proc.std_out.strip()
        if not re.match("%s\s+RUNNING" % srv_name, std_out):
            self.restart_supervisor(srv_name)
            self._cfg.log.info("supervisor service '%s' restarted" % srv_name)
        else:
            self._cfg.log.info("supervisor service '%s' already running" % srv_name)


    def restart_supervisor(self, srv_name):
        """ restart supervisord service
        """
        cmd = "supervisorctl restart %s" % srv_name
        self._cfg.log.info(cmd)
        proc = envoy.run(cmd)
        for line in proc.std_out.split('\n'):
            if re.match("%s\: started" % srv_name, line):
                self._cfg.log.info('restart successful')
                break
        else:
            msg = "Restart of '%s' went wrong>" % srv_name
            msg += " OUT:%s" % ";".join(proc.std_out.split("\n"))
            msg += " || ERR:%s" % ";".join(proc.std_err.split("\n"))
            self._cfg.log.error(msg)

    def setup(self, srv_name):
        """ setup a service
        """
        if srv_name not in self._plugins:
            self._plugins[srv_name] = getattr(qnibsetup, "qsetup_%s" % srv_name)
        srv_hosts = self._cfg.get('services', srv_name).split()
        sth_done = self._plugins[srv_name](self._cfg, srv_hosts)
        dst_list = reverse_map(srv_name)['dst']
        for dst in dst_list:
            if dst not in self._srv_check:
                self._srv_check[dst] = ""
            if sth_done:
                self._srv_check[dst] = "restart"
            elif self._srv_check[dst] != 'restart':
                self._srv_check[dst] = "check"

    def eval_dns_server(self, dns_ips):
        """ checks if given and local dns are equal

        if so, linking containers is not needed,
        it might only help out with information
        """
        do_update = False
        for ip in dns_ips:
            if self._local_dns in ("localhost", "127.0.0.1") \
            or ip == self._local_dns:
                if self.update_cfg('defaults', 'docker_dns', 'True'):
                   do_update = True
        if do_update:
            self._cfg.update_file()

    def read_local_dns_server(self):
        """ fetch the local dns IP from /etc/resolve.conf
        """
        with open("/etc/resolv.conf", "r") as fd:
            tuples = [line.split() for line in fd.readlines()]
        for key, val in tuples:
            if key == "nameserver":
                self._local_dns = val
                break

    def eval_linked_containers(self):
        """ does sth
        """
        services = {}
        keys = [var for var in os.environ.keys() if re.match("[A-Z]+_PORT_\d+_[A-Z]+_", var)]
        for key in sorted(keys):
            val = os.environ[key]
            if key.endswith("_ADDR"):
                (hostname, _, port, proto, kind) = key.split("_")
                port = int(port)
                if port in SERVICE_MAP.keys():
                    srv_name = SERVICE_MAP[port]['src']
                    if srv_name not in services:
                        services[srv_name] = []
                    services[srv_name].append(val)
        self.eval_dns_server(services['dns'])
        self._do_sth = False
        for srv_name, ip_list in services.items():
            self.add_service(srv_name, ip_list)
        if self._do_sth:
            self._cfg.update_file()

    def add_service(self, srv_name, ip_list):
        """ adds a service
        """
        if not self._cfg.has_section("services"):
            self._cfg.add_section("services")
        if self._cfg.has_option("services", srv_name):
            cur_list = self._cfg.get("services", srv_name).split(",")
        else:
            cur_list = []

        for ip in ip_list:
            val = ip
            if self._cfg.get('defaults', 'docker_dns') == 'True':
                val = socket.gethostbyaddr(ip)[0]
            if val not in cur_list:
                cur_list.append(val)
                self._do_sth = True
                self.update_cfg("services", srv_name, ",".join(cur_list))


if __name__ == "__main__":
    pass
