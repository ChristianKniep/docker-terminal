#! /usr/bin/env python
# -*- coding: utf-8 -*-

# load librarys
import os
import re
import socket
import time
import json

import envoy
import etcd
import qnibsetup

__author__    = 'Christian Kniep <christian()qnib.org>'
__copyright__ = 'Copyright 2014 Christian Kniep'
__license__   = """MIT License (http://opensource.org/licenses/MIT)"""

## Service map
SERVICE_MAP = {
    53: {'src': 'dns', 'dst': []},
    4001: {'src': 'etcd', 'dst': []},
    80: {'src': 'nginxproxy', 'dst': []},
    2003: {'src': 'carbon', 'dst': ['diamond']},
    514: {'src': 'syslog-ng', 'dst': ['syslog-ng']},
    5514: {'src': 'logstash', 'dst': ['syslog-ng']},
    }


def reverse_map(srv_name):
    """ returns port, dst
    """
    for port, val in SERVICE_MAP.items():
        if srv_name == val['src']:
            return {'port': port, 'dst': val['dst']}
    return None


class QnibSetup(object):
    """ Fetches the environment and act accordingly
    """

    def __init__(self, cfg):
        """ Init of instance
        """
        self._cfg = cfg
        if not self._cfg.has_option('defaults', 'docker_dns'):
            self.update_cfg('defaults', 'docker_dns', 'False')
        self.update_cfg('defaults', 'domain', 'local')
        if not self._cfg.has_section('local'):
            self._cfg.add_section('local')
            self._cfg.update_file()
        self._plugins = {}
        self._srv_check = {}

    def update_cfg(self, sec, opt, val):
        """ update the config and write file
        """
        return self._cfg.update_cfg(sec, opt, val)

    def run(self):
        """ main run method
        """
        ## linked stuff
        self.read_local_dns_server()
        self.eval_linked_containers()
        self.eval_services()
        ## local services
        self.config_local_srv()
        self.check_services()
        time.sleep(2)
        self.config_etcd_srv()
        self.config_node()
        self.check_services()

    def config_node(self):
        """ set values in services that are just started

        if etcd is a local service, our information needs to be set up
        """
        if self._cfg.has_option('local', 'etcd'):
            qnibsetup.qsetup_etcd(self._cfg, ["127.0.0.1",])
        else:
            qnibsetup.qsetup_etcd(self._cfg)

    def config_etcd_srv(self):
        """ discover srv via etcd /skydns entries

        """
        self._srv_check = {}
        my_domain = self._cfg.get('defaults', 'domain')
        if self._cfg.has_option('local', 'etcd'):
            client = etcd.Client(host="127.0.0.1")
        else:
            client = etcd.Client(host="etcd.qnib")
        skydns = client.read('/skydns/%s/' % my_domain, recursive=True, sorted=True)
        local_srvs = self._cfg.options('local')
        for child in skydns.children:
            #print("%s: %s" % (child.key,child.value))
            child_str = child.value.replace("'", "\"")
            child_dic = json.loads(child_str)
            if 'port' in child_dic:
                port = child_dic['port']
            elif 'Port' in child_dic:
                port = child_dic['Port']
            else:
               continue
            if 'host' in child_dic:
                host = child_dic['host']
            elif 'Host' in child_dic:
                host = child_dic['Host']
            else:
                raise ValueError("No [hH]ost specified... Big screw-up!")
            if port in SERVICE_MAP:
                srv_name = SERVICE_MAP[port]['src']
                if srv_name not in local_srvs:
                    msg = "Service name '%s'" % (srv_name)
                    msg += " not in local services '%s'" % ",".join(local_srvs)
                    self._cfg.log.debug(msg)
                    continue
                if srv_name not in self._srv_check:
                    self._srv_check[srv_name] = ""
                if getattr(qnibsetup, "qsetup_%s" % srv_name)(self._cfg, [host,]):
                    self._srv_check[srv_name] = "restart"
                else:
                    self._srv_check[srv_name] = "check"

    def config_local_srv(self):
        """ configure local services and start them
        
        ASSUMTION: All local services are under /etc/supervisord.d/*
        """
        # services from docker/terminal
        ## maybe they should be configured as well... like checked or... 
        skip = re.compile("(setup|diamond|sshd)")
        for srv in os.listdir('/etc/supervisord.d/'):
            if re.match(skip, srv):
                continue
            self._cfg.log.info("Found ini-file for '%s'" % srv)
            mat = re.match("([a-z0-9\-]+)\.ini", srv)
            if mat:
                srv_name = mat.group(1)
                if re.match("(r|c|a)\d", srv_name):
                    srv_name = 'carbon'
                    if self._cfg.has_option('local', 'carbon'):
                        continue
                plugin_name = srv_name.replace("-", "_")
                try:
                    self._cfg.log.info("Running 'qconfig_%s'" % plugin_name)
                    if getattr(qnibsetup, "qconfig_%s" % plugin_name)(self._cfg):
                        self._cfg.log.debug("srv_check['%s'] = restart" % srv_name)
                        self._srv_check[srv_name] = "restart"
                    else:
                        self._cfg.log.debug("srv_check['%s'] = check" % srv_name)
                        self._srv_check[srv_name] = "check"
                except AttributeError:
                    self._cfg.log.warn("No qconfig for '%s'" % srv_name)

    def check_services(self):
        """ checks services afterwards
        """
        for srv, stat in self._srv_check.items():
            if stat == 'restart':
                self.restart_supervisor(srv)
            elif stat == 'check':
                self.check_supervisor(srv)

    def eval_services(self):
        """ iterates over services and checks for changes
        """
        sec = 'services'
        if not self._cfg.has_section(sec):
            return
        for srv_name in self._cfg.options(sec):
            self.setup(srv_name)

    def check_supervisor(self, srv_name):
        """ checks if srv is RUNNING
        """
        cmd = "supervisorctl status %s" % srv_name
        proc = envoy.run(cmd)
        std_out = proc.std_out.strip()
        if not re.match("%s\s+RUNNING" % srv_name, std_out):
            self.restart_supervisor(srv_name)
            self._cfg.log.info("supervisor service '%s' restarted" % srv_name)
        else:
            self._cfg.log.info("supervisor service '%s' already running" % srv_name)

    def restart_supervisor(self, srv_name):
        """ restart supervisord service
        """
        cmd = "supervisorctl restart %s" % srv_name
        self._cfg.log.info(cmd)
        proc = envoy.run(cmd)
        for line in proc.std_out.split('\n'):
            if re.match("%s\: started" % srv_name, line):
                self._cfg.log.info('restart successful')
                break
        else:
            msg = "Restart of '%s' went wrong>" % srv_name
            msg += " OUT:%s" % ";".join(proc.std_out.split("\n"))
            msg += " || ERR:%s" % ";".join(proc.std_err.split("\n"))
            self._cfg.log.error(msg)

    def setup(self, srv_name):
        """ setup a service
        """
        self._cfg.log.info("setup linked container '%s'" % srv_name)
        if srv_name not in self._plugins:
            self._plugins[srv_name] = getattr(qnibsetup, "qsetup_%s" % srv_name)
        srv_hosts = self._cfg.get('services', srv_name).split(",")
        sth_done = self._plugins[srv_name](self._cfg, srv_hosts)
        dst_list = reverse_map(srv_name)['dst']
        for dst in dst_list:
            if dst not in self._srv_check:
                self._srv_check[dst] = ""
            if sth_done:
                self._srv_check[dst] = "restart"
            elif self._srv_check[dst] != 'restart':
                self._srv_check[dst] = "check"

    def read_local_dns_server(self):
        """ fetch the local dns IP from /etc/resolve.conf
        """
        with open("/etc/resolv.conf", "r") as fd:
            tuples = [line.split() for line in fd.readlines()]
        for key, val in tuples:
            if key == "nameserver":
                self._local_dns = val
                self.update_cfg('defaults', 'dns', "'%s'" % val)
                if val == "127.0.0.1":
                    self.update_cfg('defaults', 'docker_dns', 'True')
            if key == "search":
                self.update_cfg('defaults', 'domain', val)

    def eval_linked_containers(self):
        """ does sth
        """
        services = {}
        keys = [var for var in os.environ.keys() if re.match("[A-Z]+_PORT_\d+_[A-Z]+_", var)]
        for key in sorted(keys):
            val = os.environ[key]
            if key.endswith("_ADDR"):
                (hostname, _, port, proto, kind) = key.split("_")
                port = int(port)
                if port in SERVICE_MAP.keys():
                    srv_name = SERVICE_MAP[port]['src']
                    if srv_name not in services:
                        services[srv_name] = []
                    services[srv_name].append(val)
        self._do_sth = False
        for srv_name, ip_list in services.items():
            self.add_service(srv_name, ip_list)
        if self._do_sth:
            self._cfg.update_file()

    def add_service(self, srv_name, ip_list):
        """ adds a service
        """
        if not self._cfg.has_section("services"):
            self._cfg.add_section("services")
        if self._cfg.has_option("services", srv_name):
            cur_list = self._cfg.get("services", srv_name).split(",")
        else:
            cur_list = []

        for ip in ip_list:
            val = ip
            if self._cfg.get('defaults', 'docker_dns') == 'True':
                val = socket.gethostbyaddr(ip)[0]
            if val not in cur_list:
                cur_list.append(val)
                self._do_sth = True
                self.update_cfg("services", srv_name, ",".join(cur_list))


if __name__ == "__main__":
    pass
